# [Minimum Swaps To Make Sequences Increasing](https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/)

## 知识点

动态规划

## 解题思路

首先需要清楚的了解题意，两个数组只有相同索引位置的元素才可以交换，而且给出的两个数组必定能通过交换达到严格升序。

对于两个数组的每个元素来说，总是有两种选择，一是交换，或者是不交换。元素是否进行交换，将会影响到下次的抉择，随着数组元素的增加，需要进行的抉择会将树一样蔓延出来，对于这类问题，应该利用动态规划来求解。

上面提到，遍历到每个元素，都有交换与不交换两种选择，而且会分别导致两种状态。那么就需要两个 dp 数组，分别进行状态的记录。  
一个是 swap[i] ，记录第 i 个元素如果进行交换，当前最小的交换数，一个是 no_swap[i] ，记录第 i 个元素不进行交换，当前最小的交换数。

遍历两个数组，会有以下两种情况（两种情况使可以并存的）：

1. A[i] > A[i - 1] && B[i] > B[i - 1] 。当前 i 元素与 i - 1 元素，满足严格升序，一般来说，不需要进行交换，但是定义了 swap[i] 必须要进行交换，那么 swap[i] = swap[i - 1] + 1 ，因为目前只能确定 array[i] > array[i - 1] ，为了保证交换后仍然满足严格升序，需要同时进行交换。
2. A[i] > B[i - 1] && B[i] > A[i - 1] 。当满足上述条件，表示当前 i 元素可以交换，交换后满足严格升序。如果此时 i 需要交换，会有 swap[i] = min(no_swap[i - 1] + 1, swap[i]) ，则 i - 1 不交换，i 交换，如果两者都交换，那么 i 与 i - 1 必定满足情况 1 ，所以比较两者大小。  
   而 no_swap[i] = min(swap[i - 1] + 1, no_swap[i]) ，当前 i - 1 需要进行交换，而 i 不需要交换，或者两者都不用交换，那么必定满足情况 1 ，比较两者大小，选择最优方案。

最后比较 swap[-1] 与 no_swap[-1]， 较小者则为最优解。
