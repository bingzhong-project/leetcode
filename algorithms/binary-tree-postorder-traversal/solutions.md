# Binary Tree Postorder Traversal

[问题描述](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)

## 知识点

树的后序遍历，栈

## 解题思路

非递归树的后序遍历解题思路。

### 思路 1

利用栈来以迭代的方式完成树的后序遍历。  
后序遍历与中序遍历一样，需要面对的问题是折回节点的问题。在后序遍历中，当一个节点的左右子节点都完成处理后，将会返回到该节点中处理。所以后序遍历中也需要记录入过栈的元素。  
对于节点的入栈逻辑，优先将左子节点入栈，如果左子节点为空或是已经入过栈，则将不为空和没有入过栈的右子节点入栈。而当栈顶元素的左右节点为空或是访问过时，则将其出栈，完成处理。重复上述的处理逻辑，直到栈为空，完成数的遍历。

### 思路 2

在后序遍历中，当前节点的左右子节点为空或是已经访问过，则会对该节点进行处理。而如果不用对节点进行处理，就需要一直遍历节点。而根据后序遍历的规则，会先处理左节点，再处理右节点，最后处理父母节点，按照这个规则，在利用栈进行遍历时，先将栈顶右节点入栈，后再将左节点入栈，保证当左节点总是在栈顶。  
之前也提到，当栈顶节点的左右子节点为空或是访问过，就需要对该节点进行处理，是否为空很容判断，难点在于如何确定左右节点如何确定是否被访问过。所以这里使用一个 pre_node 指针，总是指向最近一次出栈的节点，而如果这个 pre_node 指针指向的节点和当前栈顶节点的左节点或是右节点相等，则表明该节点的左右节点已经进行了访问处理。  
重复上述的过程，当栈为空时，则表示完成遍历。

### 思路 3

这种思路和非递归的中序遍历是相似的。首先是优先将树的左子结点入栈，因为后序遍历和中序遍历都是优先处理左子结点的。而当结点出栈时，后序遍历就需要判断栈顶结点的右子结点是否被处理（当右子结点不为空的情况下），只有右子结点被处理完成，才轮到父结点出栈并被处理。  
而为了做到上述的判断右子结点是否被处理，所以除了当前结点指针外，还需要一个指向上一个结点出栈结点的指针。
