# [Rotate Array](https://leetcode.com/problems/rotate-array/)

## 知识点

数组

## 解题思路

首先要确认反转后，每个元素在数组中的位置，通过以下公式求出：

```python
cursor = (index + len(nums) + k) % len(nums)
```

知道每个元素反转后的位置，之后就是如何合理的交换元素位置，得到结果。

有以下例子：

```text
nums = [1, 2, 3, 4, 5, 6]
k = 2
```

遍历 nums ，从 i = 0 开始处理，使用 num 缓存数值，进行元素位置交换。交换方式如下：

```text
nums = [1, 2, 1, 4, 5, 6]
num = 3
```

```text
nums = [1, 2, 1, 4, 3, 6]
num = 5
```

```text
nums = [5, 2, 1, 4, 3, 6]
num = 1
```

这时，再继续上述的方式交换，将会重复处理之前已经处理过的元素，数组将会变得混乱，引起元素丢失。  
这时应该结束当前的处理，开始第二次处理，这时遍历下一个元素，i = 1 ，之后重复上述的交换：

```text
nums = [5, 2, 1, 2, 3, 6]
num = 4
```

```text
nums = [5, 2, 1, 2, 3, 4]
num = 6
```

```text
nums = [5, 6, 1, 2, 3, 4]
num = 6
```

这时又回到开始处理的地方，表示这次的处理也完成了。这时发现数组其实已经处理完成的了，但是在遍历中，我们无从得知已经处理完成，那么将会继续处理 i = 3 ，这样的话，数组元素也会变得混乱。  
这时观察处理过程，发现处理次数刚好等于数组长度，这是理所当然的，因为上述的流程是逐个的将数组元素交换到合适的位置，那么我们在处理过程中进行计数，当计数等于数组长度，即表示所有元素处理完成，结束遍历，这是 nums 中的元素就符合了题目要求。
