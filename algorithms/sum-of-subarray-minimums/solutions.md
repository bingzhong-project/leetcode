# [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/)

## 知识点

动态规划，栈

## 解题思路

以 [3, 1, 2, 4] 为例子分析。

遍历数组，第一个遇到的值为 3 ，子数组只有一个 [3] ，那么结果值为 3 ，res = 3 。  
之后遇到的值为 1 ，包含 1 的子数组 [3, 1] ，[1] ，那么包含 1 组成的结果值为 2 ，res + 2 = 5。  
下一个的数值为 2 ，包含 2 的子数组为 [3, 1, 2] ，[1, 2] ，[2] ，由于 2 比 1 大，那么对于对于包含了 1 的子数组来说，其结果值仍然为上一次算出的，包含 1 的子数组的结果值，即 2 ，之后再加上新的子数组 [2] ，其结果只为 4 ，res + 4 = 9。
最后的一个数值为 4 ，整个数组从左往右逐部分组成子数组，除了 [4] 之外，其余的子数组都会包含导 2 ，那么其结果值应该为上一次计算出的包含 2 的子数组结果值再加上 4 ，即最后结果为 res + 8 = 17 。

按照上述的思路，设置数组 dp ，dp[i] 为以元素 A[i] 结尾的子数组的结果值。通过上面的分析可知，当 A[i] >= A[i + 1] ，dp[i] = A[i] + dp[i - 1] 。那么当 A[i] < A[i - 1] 时，需要往前找到比其小的元素 A[j] 。如果 A[j] 不存在，那么 A[i] 就是以其结尾的子数组的最小值，dp[i] = (i + 1) \* A[i] ，如果存在 A[j] ，即再 i - j 之间的子数组中，A[i] 为最小值，到达 j 之后，即有新的最小值，所以 dp[i] = (i - j + 1) \* A[i] + dp[j] 。

整理思路，可以得出表达式：

```text
        A[i] + dp[i - 1] if A[i] >= A[i - 1]
dp[i] = A[i] * (i + 1) if A[i] < A[i - 1] and  j < 0
        A[i] * (i - j) + dp[j] if A[i] < A[i - 1] and j >= 0
```

当 A[i] >= A[i - 1] 时，很好处理，但是当 A[i] < A[i - 1] 时，需要找到 j ，如果从后往前找的话，需要 O(n) 的时间复杂度。  
其实再次分析，其实问题就是对于元素 A[i] ，找到离其最近的比起小的值，这样的话，可以利用一个自底向上递增的单调栈处理，只需要 O(1) 的时间就可以找出 j 。
