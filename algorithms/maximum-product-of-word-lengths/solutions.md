# [Maximum Product of Word Lengths](https://leetcode.com/problems/maximum-product-of-word-lengths/)

## 知识点

二进制

## 知识点

根据题目的要求，可以简单的确立下思路：

> 列表中的字符串都转化为字符集合，然后找出交集为 0 的长度相乘最大的两个字符串。

按照上述思路这么做的话，就需要 O(m \* n) 的额外空间，m 为列表长度，n 为每个字符串的平均长度。

其实，本质上的思路为找差集为 0 的两个元素。这样的话，可以尝试使用位算法。  
由于字符串只包含小写字母，那么一共只有 24 个字母，而一个整形数有 32 位，可以用一个整形数标记一个字符串中那些字符出现过（类似布隆过滤器的思路）。简而言之，存在 a 的话，第一位为 1 ，存在 b 的话第二位为 1 ，不存在的话，对应位置即为 0 。根据这个思路，利用或算法即可构建出标记了字符出现的整数数：

```python
mask |= 2**(ord(char) - ord('a'))
```

计算完列表中所有的元素之后，就将元素各个比较。假如两个字符串差集为 0 ，那么对应的位数上，必然一个是 1 一个是 0 或是都为 0 。这样的话，两两想与，结果为 0 即表示差集为 0 ，之后计算找出最长的长度乘积即可。
