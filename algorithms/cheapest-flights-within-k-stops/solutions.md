# Cheapest Flights Within K Stops

[问题描述](https://leetcode.com/problems/cheapest-flights-within-k-stops/)

## 知识点

广度优先搜索

## 解题思路

该题目的本质为在结点一定“跳转”次数的限制下，求带权图的单源最短路径。  
而求带权图的单源最短路径，可以使用 SPFA 或是 Dijkstra 算法。

### SPFA

首先参考一下 SPFA 的伪代码实现：

```python
 procedure Shortest-Path-Faster-Algorithm(G, s)
    for each vertex v ≠ s in V(G)
        d(v) := ∞
    d(s) := 0
    offer s into Q
    while Q is not empty
        u := poll Q
        for each edge (u, v) in E(G)
            if d(u) + w(u, v) < d(v) then
                d(v) := d(u) + w(u, v)
                if v is not in Q then
                    offer v into Q
```

按照伪代码的做法，对于本题来说会有一个问题，因为这条题目还有一个结点“跳转”次数的限制。SPFA 中，存储结点距离的数组 d ，总是存储结点的最短路径，如果一个结点被重复发现（即结点被多条路径所指向），那么 d 只会存储最短的路径。有以下场景，如果到达结点 A 的路径有两条，其中一条路径的距离为 2 ，但是已经经过了 2 个结点，即“跳转”了两次，而另外一条的距离为 3 ，但是只“跳转”了一次，而需要到达的目标结点为 B ，还需要一次跳转。而如果题目的“跳转”限制为 <= 2 ，这时就会出现问题，由于 d 中存储的为最短路径，那么只会记录下到达结点 A 的距离为 2 ，但是这样的话已经超出了“跳转”限制，最后只能得到错误的答案。  
要解决上述的问题，首先要允许结点重复入队，并且入队时还需要带上当前到达的路径距离。这样做的话，就不需要距离数组 d 了。当然还需要一个剪枝的操作，在处理过程中，会记录下到达目标结点的**可能的最短距离**，如果距离超过了这个可能的最短距离，就不需要将结点入队。  
当队列为空时，就得到了单源结点的最短路径。

### Dijkstra

使用 Dijkstra 算法需要依赖于优先队列。根据 Dijkstra 算法的特性，对于从优先队列中弹出的结点，总是已经找到了到达该结点的最短距离，所以从队列中出队的结点为目标结点时，直接返回其距离即可。同时我们需要记录下已经完成最短路径查找的结点，即从优先队列中出队的结点，对于已经完成处理的结点不需要再次入队，因为已经找到了到达该结点的最优解。
