# [Number of Subarrays with Bounded Maximum](https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/)

## 知识点

数组

## 解题思路

最简单的做法是利用双层循环进行遍历，将所有符合条件的子数组找出来。这样的做法是 O(n²) ，将会 TLE ，无法通过。

另一种做法则是利用数字子数组数量的特性。

有示例 A = [2, 1, 4, 3] 。

遍历 A ：  
当 i = 0 时，有子数组 [2] ，数量为 1 。  
当 i = 1 时，有子数组 [2]，[2, 1]，[1] ，数量为 3 。  
当 i = 2 时，有子数组 [2]，[2, 1]，[1]，[2, 1, 4]，[1, 4]，[4] ，数量为 6
当 i = 3 时，有子数组 [2]，[2, 1]，[1]，[2, 1, 4]，[1, 4]，[4]，[2, 1, 4, 3]，[1, 4, 3]，[4, 3]，[3] ，数量为 10 。

可以看到随着数组长度的增长，子数组的数量为一个等差数列。再观察子数组的变化，可以发现，随着数组长度的变化，新增出来的子数组必定包含新增数。

根据这个规律，可以进行如下的计算，找出 A 中所有元素都小于等于 X 的子数组。  
这样的话，只需要遍历 A ，如果遍历到的数小于等于 X ，则按照上述的规律即可知道当前符合条件的子数组数量，如果遍历到的数大于 X ，则记录下当前已知的数量，之后的视为新的数组继续进行遍历计算符合条件的子数组数量。

根据上面的做法，可以找出 A 中所有元素都小于等于 R 的子数组数量，然后再找出所有元素都小于等于 L - 1 的子数组数量，两者相减即可得到大于等于 L 且小于等于 R 的子数组数量。
