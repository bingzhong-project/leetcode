> [Sort List](https://leetcode.com/problems/sort-list/)

# 知识点

归并排序

# 解题思路

时间复杂度为 O(NlogN) 的排序算法一般是归并排序，快速排序以及堆排序。

## 归并排序

根据归并排序的原理，需要对链表进行分离以及两个有序合并操作。  
分离链表时，以链表中点为分界点，这里利用快慢指针寻找链表的中心点。然后进行链表的分离，之后就是利用递归进行排序，得到有序链表后进行合并。  
链表的归并排序在合并阶段是比列表方便的，可以简单的将链表拆分重组，而无需担心会浪费多余的空间。

## 快速排序

链表实现快速排序，使用改变节点值的方式，而不是节点位置的变换。  
根据快速排序的思路，需要选中一个比较节点，比该节点值小的节点都在该节点的左边，比该节点值大的都在右边。  
这里直接选取首节点作为比较节点，然后声明一个 swap 指针，该指针最后会与首节点进行位置交换，那么即该 swap 指针前的节点，最后都会在首节点的后边。swap 指针初始指向首节点。
之后有一个 current 节点用于遍历节点，遍历的起始位 swap.next ，每遍历到一个节点都与首节点的值进行比较，如果比首节点的值大，则遍历到下一个节点，如果比首节点的值小的话，swap 节点将指向下一个节点，然后与 current 指向的节点进行值交换。  
最后 swap 指向的节点与首节点交换位置，完成了一次排序。  
之后就是递归的重复上述的操作，直到链表排序完成。  
由于这种排序的方式直接选用首节点作为比较节点，那么原链表越有序，就越接近最坏的时间复杂度 O(N<sup>2</sup>) ，从而导致 TLE 。
