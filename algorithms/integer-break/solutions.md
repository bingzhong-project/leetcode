# Integer Break

[问题描述](https://leetcode.com/problems/integer-break/description/)

## 知识点

数论，动态规划

## 解题思路

该题有两种解法，一种是利用数论的规律，一种是利用动态规划。

### 思路 1

思路 1 利用数论进行解题。  
首先，列出一系列数的最大组合方式：

```text
2 = 1 + 1         1 * 1 = 1
3 = 1 + 2         1 * 2 = 2
4 = 2 + 2         2 * 2 = 4
5 = 3 + 2         3 * 2 = 6
6 = 3 + 3         3 * 3 = 9
7 = 3 + 4         3 * 4 = 12
8 = 3 + 3 + 2     3 * 3 * 2 = 18
9 = 3 + 3 + 3     3 * 3 * 3 = 27
10 = 3 + 3 + 4    3 * 3 * 4 = 36
...
```

当 n > 4 ，最大的组合总是优先选择 3 ，利用这个规律，总是优先让结果 res \* 3 ，让 n - 3 ，直到 n 小于或等于 4 的时候，让结果 res \* n 即可得到答案。

### 思路 2

思路 1 其实只是从少量的例子中碰巧提取了一个正确的规律，利用这个规律完成了题目。  
这里利用动态规划进行解答。  
1 个数，可以拆分成多个数，如 10 可以拆分为：

```text
10 = 1 + 9
10 = 2 + 8
10 = 3 + 3 + 4
```

然后将拆分出来的数，也可以继续进行拆分，直到拆分为最小单元，即 1 。  
基于此，假设有数组 dp ，存储从 1 到 n - 1 的最大乘积结果。有 i ，i < n ，最大乘积有可能是以下两个结果之一：

```text
dp[n] = i * dp[n - i] ## 最大乘积可能为数 i 与数 (n - i) 的乘积
dp[n] = i * (n - i) ## 最大乘积可能为数 i 与 数 (n - i) 的乘积
```

根据上述的描述进行数组 dp 的构建，dp 最后一个元素即为结果。
