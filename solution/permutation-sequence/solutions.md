> Permutation Sequence

# 知识点
回溯

# 解题思路
对于这种排列问题，在用回溯算法去解答时，可以简单的用一个已访问数组去记录已经使用了的元素，当递归调用发现元素已经在已访问数组中，就可以直接结束当前循环，进行回溯（剪枝）。  
利用上述的这种方法，记录下所有排列的结果，然后根据返回指定的一个排列结果即可。但是这样做的话，只有在树的分支较小的时候才可行，不然将会超时，因为排列数会随着数组长度而进行爆发式增长。这时，需要高效的剪枝，即尽快的回溯，不做多余的计算。  

分析本题，需要的记过是所有排列结果的第 k 个。而分析在回溯时生成的树，它的节点数量是有规律的。以 n = 5 为例，如果根节点为第 0 层，第一层的各个节点，它们之下的节点共有 24 个（每个节点），然后第二层的各个节点，它们之下的节点数有 6 个，再往下就是 2 个，再往下为 1 个。将顺序倒转过来，其实其整体的规律为一个类斐波函数，即为：
```math
f(n) = n * f(n - 1)
f(0) = 1
```

这样我们就可以计算出每一层的每个节点之下的节点数，然后就根据此来计算在每一层，想要的路径位于哪个节点，只针对这个节点进行递归，剪除所有多余的分枝。